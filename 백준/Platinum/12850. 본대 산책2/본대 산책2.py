"""
본대_산책_2의 Docstring
d가 1이면 0
d가 2면 2
d가 3이면 2

중복을 허용하되, 똑같은 지점을 곧바로 방문할 수는 없음.
정보과학관 출발 - 정보과학관 도착하는 경우의 수

정보과학관에 도착한 후 다시 나가서 다시 도착해도 되는거네. 마지막에 정보과학관이기만해도 됨.
그렇다면 d분만에 처음 오는 것, 중간에 한번이상 들리는 것
일단은 정보과학관에 처음 도착하는 경우 시간이 얼마나 걸리나 확인? ->의미 x 시간을 정하고 거기에 맞는 것을 찾는 것은 가능
일단은 브루트포스로 정보과학관에 d분에 '처음'도착하는 경우를 확인해볼까?

->인접행렬의 거듭제곱

인접행렬을 n제곱하면, n번 이동하여 i->j로 간 경우의 수를 구할 수 있다.

왜냐하면 제곱할 때 i->j = i->k, k->j의 경우의 수를 모두 곱해서 더하게 되기 때문임.
행렬의 제곱할때의 방식이 경우의수를 알아서 구해준다는 발상을 하기가 쉽지 않았다.

그렇다면 이제 제곱 자체는 분할정복 제곱하면 실행시간을 충분히 줄일 수 있게 된다.

"""
MOD = 1000000007
adj_mat = [[0,1,0,0,0,0,0,1],
           [1,0,1,0,0,0,0,1],
           [0,1,0,1,0,0,1,1],
           [0,0,1,0,1,0,1,0],
           [0,0,0,1,0,1,0,0],
           [0,0,0,0,1,0,1,0],
           [0,0,1,1,0,1,0,1],
           [1,1,1,0,0,0,1,0]]

def mul(a,b):
    r = [[0]*8 for _ in range(8)]
    for i in range(8):
        for j in range(8):
            for k in range(8):
                r[i][j] += a[i][k]*b[k][j]
                r[i][j]%=MOD
    return r

def fastmul(n,mat):
    if n==1:
        return mat
    if n%2==1:
        t = fastmul(n-1,mat)
        return mul(mat,t)
    t = fastmul(n//2,mat)
    return mul(t,t)

D = int(input())

ans = fastmul(D,adj_mat)
print(ans[0][0])
# print(ans)